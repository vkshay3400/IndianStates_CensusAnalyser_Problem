package com.bridgelabz;
//
//import com.bridgelabz.censusanalyserproject.service.StateCensusAnalyser;
//import org.junit.Rule;
//import org.junit.Test;
//import org.mockito.Mock;
//
//public class StateCensusAnalyserMockitoTest {
//
//    @Mock
//    StateCensusAnalyser stateCensusAnalyser;
//
//    @Rule
////    public MockitoRule mockitoRule = MockitoJUnit.rule();
////
////    @Before
////    public void create() throws MyExceptions {
////        stateCensusAnalyser = mock(StateCensusAnalyser.class);
////        when(stateCensusAnalyser.loadCensusData()).thenReturn();
////    }
//
//    @Test
//    public void givenIndianCensusAnalyser_StateCensusAndCode_WhenNumberOfRecordMatches_ShouldReturnTrue() {
//       // assert (29,stateCensusAnalyser();
//        //assert(29,stateCensusAnalyser(IndianCensusData));
//    }
//}
//
//
////    @Test
////    public void testQuery() {
////        In t = new ClassToTest(dataBaseMock);
////        when(stateCensusAnalyser.SORTING_MODE.("* from t")).thenReturn(true);
////        boolean check = t.query("* from t");
//
//
////    @Test
////    public void givenIndianCensusAnalyser_StateCensusAndCode_WhenNumberOfRecordMatches_ShouldReturnTrue() {
////        try {
////            StateCensusAnalyser censusAnalyserProblem = new StateCensusAnalyser(StateCensusAnalyser.COUNTRY.INDIA);
////            checkCensus = censusAnalyserProblem.loadCensusData(INDIAN_STATE_CENSUS_DATA_PATH, INDIAN_STATE_CODE_DATA_PATH);
////            Assert.assertEquals(29, checkCensus);
////        } catch (MyExceptions e) {
////            e.printStackTrace();
////        }
////    }